@{
    _Layout = "Layout.htm";
    ViewBag.Title = @Model.Name;
}

<link type="text/css" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.21/themes/ui-lightness/jquery-ui.css" rel="Stylesheet" />
<link type="text/css" href="@(Model.CSSUrl)poi.css" rel="Stylesheet" />

<script src = "@(Model.ScriptUrl)jquery-1.6.4.js" type = "text/javascript"></script>
<script src = "@(Model.ScriptUrl)jquery.signalR-0.5.2.min.js" type ="text/javascript"></script>
<script src = "@(Model.SignalrUrl)hubs" type="text/javascript"></script>
<script src = "@(Model.ScriptUrl)jquery-ui-1.8.22.custom.min.js" type="text/javascript"></script>
<script src = "@(Model.ScriptUrl)jquery.corner.js" type="text/javascript"></script>


<!--Initialization routines-->
<script type = "text/jscript">
    $(document).ready(function () {
        $.connection.hub.url = '@Model.SignalrUrl';
        var poiProxy = $.connection.proxyHub;

        //Initialize the callback function for the hub
        poiProxy.echoOnClient = function () {
            //alert("LZ SB!!!");
        }

        //Register handlers
        poiProxy.handlePresCtrlMsg = handlePresCtrlMsg;
        poiProxy.handleWhiteboardMsg = handleWhiteboardMsg;
        poiProxy.handleCommentMsg = handleCommentMsg;
        poiProxy.getSlide = getSlide;
        poiProxy.startPresentation = startPresentation;

        //Connect to the hub
        $.connection.hub.start().done(function () {
            //alert("Start done!");
            poiProxy.echoOnServer();
            poiProxy.joinSession(0);
        });

        $("#whiteboard").hide();

        $("#PresBoard").css("background-image", "url(@(Model.ImageUrl)background.png)");
        //$("#PresBoard").resizable().draggable();

        
        $("#PresBoardSideBarSlideRegion").slider({
            orientation: "vertical",
            slide: duringSlideOnSideBar,
            start: startSlideOnSideBar,
            stop: stopSlideOnSideBar
        });

        $(".ui-slider-handle").hide();


        //$("#PresBoardSideBarSlideRegion").slider("disable");

        $("#whiteBoard").click(function(){
            hideWhiteboard();
        });

        
        updateUI();
        initMenuBar();
        initDrawing();
        initLaserPointerLayer();
    });

    function updateUI() {
        // Apple detection object  
        var Apple = {};
        Apple.UA = navigator.userAgent;
        Apple.Device = false;
        Apple.Types = ["iPhone", "iPod", "iPad"];
        for (var d = 0; d < Apple.Types.length; d++) {
            var t = Apple.Types[d];
            Apple[t] = !!Apple.UA.match(new RegExp(t, "i"));
            Apple.Device = Apple.Device || Apple[t];
        }

        if (Apple.iPad) {
            initIpadLayout();
        }
        else {
            initCommonLayout();
        }
    }

    function initCommonLayout() {
        var board = $("#PresBoard");
        var totalWidth = board.width();
        var myHeight = parseInt((totalWidth) / 100 * 75);

        board.css({
            height: myHeight
        });
    }

    function initIpadLayout() {
        $("#PresBoard").css({
            width: "100%",
            left: "0%",
            top: "0%",
        });

        $("#PresBoard").css("border-radius", 0);

        var board = $("#PresBoard");
        var totalWidth = board.width();
        var myHeight = parseInt((totalWidth) / 100 * 74);

        board.css({
            height: myHeight
        });
    }

    function initLaserPointerLayer() {
        //Set the src for the laser pointer
        $("#laserPointer").attr("src", "@(Model.ImageUrl)laser.png");
    }

    function updateLaserPointerPosition(point) {
        var x = 100 * point.X / $("#canvasStack").width();
        var y = 100 * point.Y / $("#canvasStack").height();

        $("#laserPointer").css({
            left: parseInt(x) + "%",
            top:  parseInt(y) + "%"
        });
    }

</script>

<!--Handler functions -->
<script type = "text/jscript">
    function initMenuBar() {
        $("#DrawingItem > img").attr("src", "@(Model.ImageUrl)pencil.png");
        $("#ColorItem > img").attr("src", "@(Model.ImageUrl)graph_bar.png");
        $("#CommentItem > img").attr("src", "@(Model.ImageUrl)speech_bubble.png");
        $("#ControlItem > img").attr("src", "@(Model.ImageUrl)Control_icon.png");

        $("#DrawingItem > img").click(function(){
            showWhiteboard();
        });
    }

    
    function duringSlideOnSideBar(event, ui) {
        if (!isStart) {
            startValue = ui.value;
            //console.log("Start: " + startValue);
            isStart = true;
        }
        else {
            var percent = curTransformValue - (ui.value - startValue) + "%";
            //console.log("Slide: " + percent);
            $("#PresBoardSideBar").css("top", percent);
        }
    }

    function startSlideOnSideBar(event, ui) {
        isStart = false;
    }

    function stopSlideOnSideBar(event, ui) {
        curTransformValue = curTransformValue - (ui.value - startValue);
    }

    function handlePresCtrlMsg(msgString) {
        var msg = jQuery.parseJSON(msgString);

        switch (msg['CtrlType']) {
            case 0: //Next
                presentationNext();
                break;
            case 1: //Prev
                presentationPrev();
                break;
        };
    }

    function startPresentation() {
        curSlideIndex = 0;
        showSlideInMainView(curSlideIndex);
    }

    function presentationNext() {
        if(curSlideIndex < preloadSlideIndex)
        {
            curSlideIndex++;
            console.log("Current slide: " + curSlideIndex);
            showSlideInMainView(curSlideIndex);
        }
    }

    function presentationPrev() {
        if(curSlideIndex > 0) {
            curSlideIndex--;
            console.log("Current slide: " + curSlideIndex);
            showSlideInMainView(curSlideIndex);
        }
    }

    function showSlideInMainView(slideIndex) {
        $(".MainSlideView").attr("src", $("#"+slideIndex).attr("src"));
    }

    function getSlide(slideIndex) {
        console.log("Get slide: " + slideIndex);
        if(slideIndex > preloadSlideIndex) {
            preloadSlideIndex = slideIndex;
        }
        
        url = "@(Model.SessionUrl)" + "?sessionId=0&slideIndex=" + slideIndex;

        var img = $('<img>', {
            id: slideIndex,
            class: 'SlideAbstractView',
            src: url
        });

        img.click(function () {
            showSlideInMainView(slideIndex);
        });

        var topPercent = slideIndex*110 + 5;
        img.css('top', topPercent + "%");

        $("#PresBoardSideBar").append(img);
    }

    function handleWhiteboardMsg(msgString) {
        var msg = jQuery.parseJSON(msgString);

        switch(msg['CtrlType']) {
            case 0:
                showWhiteboard();
                break;
            case 1:
                hideWhiteboard();
                break;
        };
    }

    function showWhiteboard() {
        
        $("#whiteBoard").animate({
            top : "15%"
        },  200, 'linear', function () {
        
        /*
            //Start another round 
            $("#whiteBoard").animate({
                top : "13%"
            },  50, 'linear', function () {
                $("#whiteBoard").animate({
                    top : "15%"
                },  50, 'linear', function () {
                
                });
            });*/
        });

        //$("#whiteBoard").slideDown('slow', function(){});
    }

    function hideWhiteboard() {
        $("#whiteBoard").animate({
            top : "19%"
        },  50, 'linear', function () {
            $("#whiteBoard").animate({
                top : "-82%"
            },  400, 'linear', function () {
                
            });
        });
    }

    function handleCommentMsg(msgString) {
        var comment = jQuery.parseJSON(msgString);
        tool.loadComment(comment);
        
        //alert('Handle comment!');
    }
</script>

<!--Comment tools-->
<script type="text/javascript">

    function initDrawing() {
        var canvasStack = document.getElementById('canvasStack');

        // Attach the mousedown, mousemove and mouseup event listeners.
        canvasStack.addEventListener('mousedown', ev_canvas, false);
        canvasStack.addEventListener('mousemove', ev_canvas, false);
        canvasStack.addEventListener('mouseup', ev_canvas, false);

        //Attach the touchstart, touchmove and touchend event listeners.
        canvasStack.addEventListener('touchstart', ev_canvas, false);
        canvasStack.addEventListener('touchmove', ev_canvas, false);
        canvasStack.addEventListener('touchend', ev_canvas, false);
    }
    
    // This painting tool works like a drawing pencil which tracks the mouse 
    // movements.
    function tool_pencil() {
        var tool = this;
        this.started = false;
        var curve;

        var stackSize = 0;
        this.undo = removeLastDrawing;
        this.loadComment = loadComment;

        var drawings = [];
        var textboxes = [];

        function initDrawingContext() {
            var canvas = document.getElementById("canvas" + stackSize);
            if(canvas === null)
            {
                setupDrawingCanvas(stackSize);
                stackSize++;
            }
            else
            {
                curve = new POIDrawingCurve(canvas.getContext('2d'));
            }
        }

        function setupDrawingCanvas (canvasId) {

            var newCanvas = $('<canvas>Not supported!</canvas>');
            newCanvas.attr("id", "canvas" + canvasId);
            newCanvas.attr("width", $("#canvasStack").width());
            newCanvas.attr("height", $("#canvasStack").height());

            newCanvas.css({
                position: "absolute",
                left: "0%"
            });

            $("#canvasStack").append(newCanvas);
            var newCurve = new POIDrawingCurve(newCanvas[0].getContext('2d'));
            curve = newCurve;

            drawings[canvasId.toString()] = newCurve;
        }

        function removeLastDrawing() {
            var canvas = document.getElementById(stackSize - 1);
            if (canvas !== null) {
                canvas.parentNode.removeChild(canvas);

                delete drawings[stackSize.toString()];
                stackSize--;
            }
        }

        function loadComment(comment) {

            if (isPointerMode) {
                if (comment.NumBeizerPath == 1) {
                    updatePointer(comment.Paths[0]);
                }
                else {
                    //Print out error
                    console.log("Not valid pointer message: num path");
                }
            }
            else for (var i = 0; i < comment.NumBeizerPath; i++) {
                updateDrawing(comment.Paths[i]);
            }

            for (var i = 0; i < comment.NumText; i++) {
                updateTextbox(comment.Texts[i]);
            }
        }

        function updatePointer(path) {
            if (path.Mode == 0) {
                //Realtime mode, extract the position from the path
                var x = path.Points[0].X;
                var y = path.Points[0].Y;
            }
            else {
                //Print out error
                console.log("Not valid pointer message: mode");
            }
        }

        function updateDrawing(path) {
            switch (path.Mode) {
                case 0: //Realtime
                    //Check if the context with given depth exists
                    if (drawings[path.Depth.toString()] == null) {
                        setupDrawingCanvas(path.Depth);
                    }

                    var curDrawing = drawings[path.Depth.toString()];
                    curDrawing.setupColor(
                        "rgb(" + path.Color.R + ", " + path.Color.G + ", " + path.Color.B + " )"
                    );
                    curDrawing.updateDrawing(path);
                    curDrawing.render();

                    break;
                case 1: //All
                    break;
            };
        }

        //Load the text comment 
        function updateTextbox(text) {
           
            switch (text.Mode) {
                case 0: //Create
                    if (textboxes[text.Depth.toString()] == null) {
                        textboxes[text.Depth.toString()] = new POITextBox(text);
                    }
                    break;
                case 1: //Pop
                    var curText = textboxes[text.Depth.toString()];
                    curText.popOut();
                    break;
                case 2: //Collapse
                    var curText = textboxes[text.Depth.toString()];
                    curText.collapse();
                    break;
                case 3: //Position changed
                    var curText = textboxes[text.Depth.toString()];
                    curText.updatePosition(text.X, text.Y);
                    break;
                case 4: //Content changed
                    var curText = textboxes[text.Depth.toString()];
                    curText.updateContent(text.Msg);
                    break;
                case 5: //Delete
                    //To be completed

                    break;                
            }
        }


        // This is called when you start holding down the mouse button.
        // This starts the pencil drawing.
        this.mousedown = function (ev) {
            initDrawingContext();

            var point = new point2D();
            point.construct(ev._x, ev._y);
            curve.addPointToCurve(point);
            tool.started = true;
        };

        this.touchstart = function (ev) {
            initDrawingContext();

            var point = new point2D();
            point.construct(ev._x, ev._y);
            curve.addPointToCurve(point);
            tool.started = true;
        };

        // This function is called every time you move the mouse. Obviously, it only 
        // draws if the tool.started state is set to true (when you are holding down 
        // the mouse button).
        this.mousemove = function (ev) {
            if (tool.started) {
                //context.lineTo(ev._x, ev._y);
                //context.stroke();
                var point = new point2D();
                point.construct(ev._x, ev._y);
                curve.addPointToCurve(point);
                curve.render();
            }
        };

        this.touchmove = function (ev) {
            if (tool.started) {
                //context.lineTo(ev._x, ev._y);
                //context.stroke();
                var point = new point2D();
                point.construct(ev._x, ev._y);
                curve.addPointToCurve(point);
                curve.render();
            }
        };

        // This is called when you release the mouse button.
        this.mouseup = function (ev) {
            if (tool.started) {
                tool.mousemove(ev);
                tool.started = false;
            }
        };

        this.touchend = function (ev) {
            if (tool.started) {
                //tool.touchmove(ev);
                tool.started = false;
            }
        };
    }



    // The general-purpose event handler. This function just determines the mouse 
    // position relative to the canvas element.
    function ev_canvas(ev) {
        switch (ev.type) {
            case "touchstart":
            case "touchmove":
            case "touchend":
                ev.preventDefault();
                break;
        }

        /*
        if (ev.layerX || ev.layerX == 0) { // Firefox
            ev._x = ev.layerX;
            ev._y = ev.layerY;
        } else if (ev.offsetX || ev.offsetX == 0) { // Opera
            ev._x = ev.offsetX;
            ev._y = ev.offsetY;
        }
        */

        ev._x = ev.pageX - $('#canvasStack').offset().left;
        ev._y = ev.pageY - $('#canvasStack').offset().top;

        // Call the event handler of the tool.
        var func = tool[ev.type];
        if (func) {
            func(ev);
        }
    }
</script>

<script type="text/javascript">
    
</script>

<!--Textcomment class-->
<script type="text/javascript">
    function POITextBox(textComment) {
        var isCollapsed;
        var depth;

        this.init = init;
        this.updateContent = updateContent;
        this.updatePosition = updatePosition;
        this.popOut = popOut;
        this.collapse = collapse;

        init(textComment);

        function init(textComment) {
            var container = $('<div></div>', {
                id: "textbox" + textComment.Depth
            });

            container.css({
                position: "absolute",
                left: textComment.X * 100 + "%",
                top: textComment.Y * 100 + "%",
                width: "1%",
                height: "1%"
            });
            
            //An image tag
            var icon = $('<img>', {
                src: "@(Model.ImageUrl)speech_bubble.png"
            });

            icon.css({
                position: "absolute",
                width: "400%",
                height: "auto",
            });

            //An text field
            var textField = $('<textarea></textarea>', {
                rows: 20,
                cols: 10
            });

            textField.css({
                position: "absolute",
                width: "3000%",
                height: "5000%"
            });

            var iconContainer = $('<div></div>', {

            });

            var textFieldContainer = $('<div></div>', {

            });

            iconContainer.css({
                position: "absolute",
                width: "100%",
                height: "100%"
            });

            textFieldContainer.css({
                position: "absolute",
                width: "100%",
                height: "100%"
            });

            iconContainer.append(icon);
            textFieldContainer.append(textField);

            container.append(iconContainer);
            container.append(textFieldContainer);
            $("#canvasStack").append(container);

            $("#textbox" + textComment.Depth + " > div > textarea").hide();
            isCollapsed = true;
            depth = textComment.Depth;
        }

        function collapse() {
            if (!isCollapsed) {
                $("#textbox" + depth + " > div > textarea").hide();
                $("#textbox" + depth + " > div > img").show();

                isCollapsed = true;
            }
        }

        function popOut() {
            if (isCollapsed) {
                $("#textbox" + depth + " > div > textarea").show();
                $("#textbox" + depth + " > div > img").hide();

                isCollapsed = false;
            }
        }
        
        function updateContent(msg) {
            $("#textbox" + depth + " > div > textarea").val(msg);
        }

        function updatePosition(x, y) {
            //Update the container position
            $("#textbox" + depth).css({
                left: x * 100 + "%",
                top: y * 100 + "%"
            });
        }
    }
</script>

<!--Drawingcomment class-->
<script type = "text/javascript">
    function POIDrawingCurve(myContext) {
        //Private variables
        var segments = [];
        var numPoints = 0;
        var startPoint;
        var context = myContext;
        var color;

        //Public functions
        this.render = render;
        this.addPointToCurve = addPointToCurve;
        this.updateDrawing = updateDrawing;
        this.setupColor = setupColor;

        function updateDrawing(path) {
            for (var i = 0; i < path.NumPoints; i++) {
                var curPoint = new point2D();
                curPoint.construct(
                    path.Points[i].X * $("#canvasStack").width(),
                    path.Points[i].Y * $("#canvasStack").height()
                );

                addPointToCurve(curPoint);
            }
        }

        function setupColor(myColor) {
            color = myColor;
        }

        //Function definitions
        function addPointToCurve(point) {
            
            //For testing purpose only
            updateLaserPointerPosition(point);

            var newSegment;

            if (numPoints < 1) {
                startPoint = point;
            }
            else if (numPoints < 2) {
                newSegment = findBezierSegment(startPoint, startPoint, point, point);
                segments.push(newSegment);
            }
            else {
                var lastSegment = segments.pop();
                var lastPoint = lastSegment.endPoint;

                var lastSecondPoint;
                if (segments.length == 0) {
                    lastSecondPoint = startPoint;
                }
                else {
                    var lastSecondSegment = segments[segments.length - 1];
                    lastSecondPoint = lastSecondSegment.endPoint;
                }

                var updatedLastSegment = new bezierSegment(
                    lastSegment.ctrlPoint1,
                    findSecondCtrlPoint(lastSecondPoint, lastPoint, point),
                    lastPoint
                );

                newSegment = findBezierSegment(lastSecondPoint, lastPoint, point, point);

                segments.push(updatedLastSegment);
                segments.push(newSegment);
            }

            numPoints = numPoints + 1;
        }

        function render() {
            context.restore();
            context.beginPath();
            context.moveTo(startPoint.X, startPoint.Y);

            var segment;
            for (var i = 0; i < segments.length; i++) {
                segment = segments[i];
                context.bezierCurveTo(
                    segment.ctrlPoint1.X, segment.ctrlPoint1.Y,
                    segment.ctrlPoint2.X, segment.ctrlPoint2.Y,
                    segment.endPoint.X, segment.endPoint.Y
                );
            }

            context.strokeStyle = color;
            context.stroke();
            context.closePath();
            context.save();
        }

        function findFirstCtrlPoint(prev, first, second) {
            var myX = (second.X - prev.X) / 6 + first.X;
            var myY = (second.Y - prev.Y) / 6 + first.Y;

            var newPoint = new point2D();
            newPoint.construct(myX, myY);
            return newPoint;
        }

        function findSecondCtrlPoint(first, second, next) {
            var myX = (first.X - next.X) / 6 + second.X;
            var myY = (first.Y - next.Y) / 6 + second.Y;

            var newPoint = new point2D();
            newPoint.construct(myX, myY);
            return newPoint;
        }

        function findBezierSegment(prev, first, second, next) {
            var segment = new bezierSegment(
                findFirstCtrlPoint(prev, first, second),
                findSecondCtrlPoint(first, second, next),
                second
            );

            return segment;
        }

    }

    function point2D() {
        var _point = this;
        this.X = 0;
        this.Y = 0;

        this.construct = construct;
        this.copy = copy;

        function construct(myX, myY) {
            _point.X = myX;
            _point.Y = myY;
        }

        function copy(point) {
            _point.X = point.X;
            _point.Y = point.Y;
        }
    }

    function bezierSegment(p1, p2, p3) {
        this.ctrlPoint1 = new point2D();
        this.ctrlPoint1.copy(p1);

        this.ctrlPoint2 = new point2D();
        this.ctrlPoint2.copy(p2);

        this.endPoint = new point2D();
        this.endPoint.copy(p3);
    }
</script>

<script type="text/javascript">
    //Global variables definitions

    // The pencil tool instance.
    var tool = new tool_pencil();
    
    //For slider region control
    var isStart = false;
    var startValue;
    var curTransformValue = 0;

    //For showing presentation
    var curSlideIndex = 0;
    var preloadSlideIndex = 0;

    //For switching between drawing and pointer mode
    var isPointerMode = true;

</script>